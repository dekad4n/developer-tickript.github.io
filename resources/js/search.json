[[{"l":"Introduction","p":["Introducing our cutting-edge Flutter ticket app powered by Web3 technology! With our app, you can create, manage, and participate in exciting events like never before. Whether you're organizing a concert, sports game, conference, or any other event, our app provides a seamless and secure platform for all your ticketing needs.","One of the key features of Tickript is the ability to create events with just a few taps. You can set up event details such as date, time, and ticket pricing, and our app will generate unique and verifiable tickets using blockchain technology. This ensures that your event tickets are tamper-proof and cannot be duplicated, providing enhanced security and trust.","Selling and transferring tickets has never been easier with Tickript. You can list your tickets for sale on the app's marketplace, where buyers can securely purchase tickets using cryptocurrency or other payment methods. Tickets can also be easily transferred to friends, family, or other users with just a few clicks, making it convenient and hassle-free to manage your tickets.","Tickript also supports auctions, allowing users to create ticket auctions and bid on tickets in a transparent and decentralized manner. The highest bidder wins the auction, and the tickets are automatically transferred to their digital wallet upon successful bid, ensuring a fair and efficient auction process.","With Tickript's QR code scanning feature, you can easily verify the authenticity of tickets at the event venue. Simply scan the QR code that is generated by the customer's Tickript, and Tickript will quickly validate the ticket's authenticity and check if it has been used before, preventing fraud and ensuring a smooth entry process.","In summary, Tickript provides a secure, transparent, and user-friendly solution for creating, managing, and participating in events. With features such as event creation, ticket sales and transfers, auctions, and QR code validation, Tickript revolutionizes the way tickets are bought, sold, and used, making event management a breeze. Join us and experience the future of ticketing!"]}],[{"l":"Introduction to Installation","p":["Tickript have been tested with Android emulators. We do not promise to work on any devices other than Androids. Also, if you are going to deploy our backend in your local machine, we all have used Windows machines (due to our lack of resources)."]}],[{"l":"Basic Installation"},{"l":"Prerequisites","p":["Prerequisites of basic installation parts are:","Node.js with CLI","Flutter","Android Emulator"]},{"l":"Deploying Backend on Your Local","p":["If you are not going to use our backend services that are deployed on online, you may want to look at this part. Other than that, you can skip into mobile part.","After installing node.js, go to project's root folder that you are cloned from GitHub.","After that, in command line, run:","Now, we have installed our dependencies, therefore we can run the backend. However, if you are getting any errors, you may want to install packages that throws the error by:","After that, create a file named .env in your root folder of the backend project. The environment file should have following variables:","After these steps, if you have nodemon in your machine, start the backend by:","If you do not have nodemon in your machine, use:"]},{"l":"Installing the Mobile Project","p":["Clone the mobile project from GitHub. Then, go to project's root folder and open an .env file. After opening it, change its content to:","Then, in the project directory, run:","If you do not face any error, open an Android Emulator and run project through your personal choices.","Add mumbai testnet into your Metamask's networks, and switch to it.","That is it! You have installed our development environment on your local machine."]}],[{"l":"Deploying the Backend","p":["As Sabanci University students, the Sabanci University's IT team has given as a container in which we could deploy our backend. This process only works for the ones who are trying to deploy their application through Sabanci University network.","We will cover every step we did to deploy our backend."]},{"l":"1. Install OpenVPN","p":["The service is only accessible when one logged in to Sabanci University network. Therefore, the one should use the Sabanci University network or should use OpenVPN to connect Sabanci University network.","Install OpenVpn from this link. Then open it and enter your su-username and password."]},{"l":"2. Login through SSH","p":["Prerequisites: a command line in which ssh service is usable.","Open a prefferred command line.","It team should have given you a DNS, a username and password. Enter it to command line like this:","Then, enter your password."]},{"l":"3. Using already installed Podman","p":["It team provides podman to you. You would try a basic command like:","It works and when you try your api, it will response to you. However, avoid this, since logging-out causes stop of the container. Do these instead:","Open a screen session (write screen to logged in container):","Write podman commands now:","Press ctrl+a then d","Write exit to logged in container.","Now, your backend is always awake."]},{"i":"why-not-to-use-systemctl-loginctl-nohup-or-tmux","l":"Why not to use systemctl, loginctl, nohup or tmux","p":["systemctl, loginctl or tmux requires sudo permission. We do not have that.","Nohup closes after closing the current login session (terminal with writing exit or forcing to close)."]}],[{"l":"Install with Docker","p":["If you have one of our docker files, use following steps to deploy your backend.","Clone the docker file.","Run docker:","After that, you can use http://YOUR_IPv4_ADDRESS:8080 as your backend."]}],[{"l":"Introduction to Modals","p":["Our modals are what we use in our Mongodb Atlas Database. We have created them with mongoose, however, in this section we will just describe what modals' variables are.","When we are inserting, deleting, updating a field in Mongodb, we always use modals. Therefore, they are important to understand."]}],[{"l":"Auction Modal","p":["When our auction contract is created, we realized that we need an auction id to send. Therefore, we have created this modal to just serve this specific need.","It has 2 fields:"]},{"l":"auctionId","p":["auctionId is a Number field and automatically generated by mongoose sequence."]},{"l":"eventId","p":["eventId is a Number field and is given to backend to match auction with events."]}],[{"l":"Category Modal","p":["Category modals represents categories in database. Even though they are constant now, we wanted the flexibility of adding categories to database.","Category modal have 2 fields:"]},{"l":"image","p":["image is a required string field. It is fed with an image URL."]},{"l":"name","p":["name is a required string field. It is category's name."]}],[{"l":"Event Modal","p":["Event modal used through creation of events, update of events processes. An event model has many fields, let's describe them."]},{"l":"owner","p":["owner field is a required string field. It is the public address of event creator"]},{"l":"coverImageURL","p":["coverImageURL field is a required string field. We generally use cloudinary links for cover images. It is the image when you click an event."]},{"l":"title","p":["title field is a required string field. It is the title when you click an event."]},{"l":"startDate","p":["startDate field is a required string field (not Date!)."]},{"l":"endDate","p":["endDate field is a required string field (not Date!)."]},{"l":"startTime","p":["startTime field is a required string field (not Date!)."]},{"l":"endTime","p":["endTime field is a required string field (not Date!)."]},{"l":"category","p":["category field is foreign key of category names. It is a required string field."]},{"l":"description","p":["description is a required string field."]},{"l":"integerId","p":["When we are creating event models, we wanted to have an integer id to send to chain. Since our contract doesn't work with string ids, we have created integerId field. This field is fed from an automatic sequence, therefore, you do not need to input it anywhere. The type of integerId is Number, and since it is automatically generated it is not required but always exists."]}],[{"l":"Ticket Modal","p":["Ticket modal is created to see if the ticket is checked but not used before. This is created because one could use a ticket many times before a event checker sent the ticket used information to chain.","It has 2 fields:"]},{"l":"tokenId","p":["tokenId is a required Number field, and generated by chain. After the tokenId generated by chain, we use that tokenId to feed this data. TokenIds are generated in minting process."]},{"l":"controllerAddress","p":["controllerAddress is a required string field. It shows who controlled the ticket, therefore it contains public address of the controller. We have created this field to erase data with 1 query."]}],[{"l":"User Modal","p":["Our user modal is used when a user logins with Metamask. Since we wanted to customize our users, we created such modal. The fields of user model will be described below."]},{"l":"publicAddress","p":["publicAddress is a required string field. It is user's public wallet address."]},{"l":"name","p":["name is a string field. Once an user logs in, the default name of the user is its public address. However, an user can change its name."]},{"l":"username","p":["name is a string field. Once an user logs in, the default username of the user is its public address. However, an user can change its username."]},{"l":"nonce","p":["nonce is a string field. It is set when user is created by uuid.v4() algorithm. We use that to authenticate user sometimes."]},{"l":"avatar","p":["avatar is a string field. It provides user's profile picture in terms of URLs."]}],[{"l":"Introduction to Workflows","p":["Auction","Authentication","Backend","Category","Classes","Connection to backend","Event","General","In this part we will look at these:","Market","Middlewares","Mobile","Providers","Routes (APIs)","The main goal of Workflows part is to introduce operational and algorithmic part of Tickript. Mainly this part is for developers. Therefore, if you do not have any background about Software Engineering, see Usage.","The parts will provide general workflow, therefore they will not include any part of our codes.","Ticket","User","Utils"]}],[{"l":"Authentication Mechanism","p":["Our authentication mechanism has 2 parts: Authentication with Metamask and Authentication with JWT token."]},{"l":"Authentication with Metamask","p":["In the mobile part, we have created login button. Whenever a user clicks onto login button, we open Metamask with WalletConnect API. If user permits logging in, the user will pass to JWT Authorization part."]},{"l":"JWT Authorization","p":["Our JWT Authorization is based on the backend. When a user is logged into Metamask, the User Provider forces user to sign a Metamask request. Then, we send signature and nonce of the user to backend, and verify if the user is the authorized user. Backend responds with a JWT token, which is deposited in the User Provider of the mobile part.","If a backend service needs authentication, we send following code part in the header:","That is how we handle Authorization via our backend services."]}],[{"l":"General Structure"},{"l":"Backend","p":["Our backend works with node.js/express/mongodb stack. Mongodb databse is based on Mongodb Atlas Cloud Database, therefore its link is needed when deploying the backend. We used the service architecture, which means we have:","Routes","Middlewares","Also, since we wanted to use mongoose, we have implemented Model-View-Controller architecture, therefore, the backend works with Models.","In the backend, we use several packages to reach our aim. The most important packages and services we use are:","Express","Alchemy","ipfs-only-hash","Axios","Cloudinary","Mongoose","jsonwebtoken","uuid"]},{"l":"Mobile","p":["Our mobile application is written with Flutter. It has atomic-design architecture (mostly), which means we have divided our components into four groups:","atoms","molecules","organisms","pages","Also, to simplfy login processes, we have used Provider Structures.","While we are developing, we used following packages and services to reach our aim:","WalletConnect","Alchemy","urllauncher","qrcodescanner"]}],[{"l":"Transactions","p":["To prevent repeated explanations in the document, this part will explain how Tickript handles the transaction in the general structure.","Every transaction starts at the mobile application. The mobile application collects necessary inputs from the user to call the corresponding backend service. Then, it requests to backend service with correct format.","After that, backend service responses to mobile app with 2 different statements:","Valid","Error","Backend always encodes the datas with encodeABI() function of the contract, however, depending on the inputs the state changes.","If the inputs are valid and transaction is available to do, backend service sends following data structure to user:","The mobile application gains the transactionParameter and sends it to chain via using alchemy.sendTransaction() function. If the signature of user is needed, it is handled via Metamask Provider."]}],[{"l":"Authentication Middleware","p":["Tickript's authentication system in the Tickript's backend services are based on the Authentication Middleware. As General Authentication explains, the backend's authentication is handled with Json Web Tokens (JWTs).","In every service that needs authentication calls Authentication Middleware before it proceeds any other work.","The Authentication Middleware takes the token that is sent with header Authorization. Then, it proceeds sent token and checks whose token is sent. It finds it the database whose token it is and adds user's information to request according to User Modal."]}],[{"i":"auction-route-auction","l":"Auction Route (/auction)","p":["The Auction Route's aim to handle auction data or get data about tickets/events that is related with auction mechanism."]},{"i":"get-auctions-by-event-ideventid","l":"[GET] /auctions-by-event-id?:eventId","p":["The /auctions-by-event-id?:eventId finds all auctions under the event with id eventId with calling GetAuctionInfo function of our Auction Contract. It returns list of auctions."]},{"i":"post-create-bid-item","l":"[POST] /create-bid-item","p":["The /create-bid-item service's aim to prepare data to create a bid item (start auction). It takes ticketId, eventId, startPrice, time and prepares transactionParameters with createBidItem function of our contract."]},{"i":"post-stop-auction","l":"[POST] /stop-auction","p":["The /stop-auction service's aim to prepare data to stop auction with id auctionId. It encodes data with StopAuction function of our Auction Contract."]},{"i":"get-get-auction","l":"[GET] /get-auction","p":["The /get-auction?:auctionId returns auction data of auction with id auctionId by calling GetAuctionInfo function of our Auction Contract."]},{"i":"get-list-prev-bidsauctionid","l":"[GET] /list-prev-bids?:auctionId","p":["The /list-prev-bids?:auctionId returns previous bids that belongs to auction with id auctionId by calling listPrevBids method of our Auction Contract."]},{"i":"post-bid","l":"[POST] /bid","p":["The /bid service's aim to prepare data for bidding to an bidding item with auctionId. It also takes bidPrice to encode with placeBid function of our Auction Contract and returns encoded data to user."]},{"i":"post-finish-bid","l":"[POST] /finish-bid","p":["The /finish-bid service's aim to prepare data for ending auction with id auctionId with encoding data with finishBid function of our Auction Contract."]},{"i":"post-payback-prev-bids","l":"[POST] /payback-prev-bids","p":["The /payback-prev-bids service's aim to prepare data for refunding old bids that belongs to auctionId by encoding the data with payBackPrevBids function of our Auction Contract."]}],[{"i":"authentication-route-auth","l":"Authentication Route (/auth)","p":["Authentication Service's aim is to provide a login system. It has only 1 useful endpoint called /login."]},{"i":"login","l":"/login","p":["The login endpoint has 2 paths:","User is already signed up","User that did not signed up","With looking session value of user, /login method decides the signed-up state of the user. If the user is signed up, it generates a JWT token and calls our contract's verifyEventOwner method to see if user is whitelisted. Then, it sends both information to user.","If user is not signed up, it requires 2 parameters: nonce and signature. Then, using nonce and signature, it re-generates user's public address and adds a user with that public address and nonce to MongoDb Atlas Database. After that, it verifies if user is whitelisted already. Then, it returns User Modal and whitelist information to the requesting user."]}],[{"i":"category-route-category","l":"Category Route (/category)","p":["Since categories are not changable by end-users, category services only consist getters for ordinary users. However an admin of Tickript can add an category. Other than that category services are not in touch with any contract methods."]},{"i":"get-get-all","l":"[GET] /get-all","p":["The /get-all service of category route gets all categories from the MongoDb Atlas database and returns them to the requesting user."]},{"i":"post-add","l":"[POST] /add","p":["The /add service is called by Tickript admins and takes 2 inputs at it's body according to Category Modal: image and name. After validating the inputs, it adds the category into MongoDb Atlas Database."]}],[{"i":"event-route-event","l":"Event Route (/event)","p":["Event Route is created to handle get, put, post and delete operations that are related to Events. Event Route uses both contract and MongoDb methods in it."]},{"i":"get-id","l":"[GET] /:id","p":["The /:id service of the Event Route returns the Event Modal that corresponds to queried id. After validating the query, it finds the event by id in the MongoDb Atlas Database and returns it to requesting user."]},{"i":"get-get-random-event","l":"[GET] /get-random-event","p":["The /get-random-event service of the Event Route returns the Event Modal which is a random event. It returns a single random event to requesting user."]},{"i":"get-minted-event-ticket-tokensintegerid","l":"[GET] /minted-event-ticket-tokens?:integerId","p":["The /minted-event-ticket-tokens service of the Event Route returns the Tickets that are created under given integerId of the Event. It calls .getEventTicketList method of our contract and returns the list of tickets under the event to requesting user."]},{"i":"post-create","l":"[POST] /create","p":["The /create service of the Event route creates a new Event according to Event Modal. It requires authentication. After validating authentication and inputs, it creates a new event in the MongoDb Atlas Database"]},{"i":"post-set-ticket-controller","l":"[POST] /set-ticket-controller","p":["The /set-ticket-controller service of the Event Route returns a transaction data to add new ticket controller to the event. It encodes the given publicAddress and eventID with our Minting Contract and returns transaction parameters as stated in Transactions. It requires authentication."]},{"i":"post-is-ticket-controller","l":"[POST] /is-ticket-controller","p":["The /is-ticket-controller service of the Event Route returns if the one is a ticket controller for corresponding event. It requires authentication. By calling our verifyTicketController method of Mint Contract, it checks if user with publicAddress is an Event Controller for the event with eventID."]}],[{"i":"market-route-market","l":"Market Route (/market)","p":["Market route is specifically created to work with Market Contract."]},{"i":"get-market-itemtokenid","l":"[GET] /market-item?:tokenId","p":["The /market-item service of the Market Route gets the item that is an element market contract by using tokenId query parameter via calling NFTItem method of our Market Contract. It returns data of that token to the requesting user."]},{"i":"get-market-items-alleventid","l":"[GET] /market-items-all?:eventId","p":["The /market-items-all service of the Market Route gets all the tickets which is in Market Block and has the eventId. It gets them via calling ListEventTicketAll method of our Market Contract and returns list of tickets to the requesting user."]},{"i":"get-transferable-idseventidpublicaddress","l":"[GET] /transferable-ids?:eventId&:publicAddress","p":["The /transferable-ids service of the Market Route return all the tickets that is transferrable under eventId and owned by publicAddress. It gets them via calling TransferableIds method of our MarketContract and returns them to requesting user."]},{"i":"post-transfer","l":"[POST] /transfer","p":["The /transfer service of the Market Route returns data for the Transfer transaction according to Transactions. It gets tokenId and a toAddr, which means which user you want to send the ticket, and returns transaction data by encoding with TransferTicket method of our Market Contract."]},{"i":"post-resell","l":"[POST] /resell","p":["The /resell service of the Market Route returns data for the Resell transaction according to Transactions. It gets tokenId and a price, returns transaction data by encoding with ResellTicket method of our Market Contract. Resell means selling a ticket at second or more time."]},{"i":"post-sell","l":"[POST] /sell","p":["The /sell service of the Market Route returns data for the Sell transaction according to Transactions. It gets price, eventId, amount and transactionRight returns tra transaction data by encoding with createMarketItem method of our Market Contract. It is called when a ticket will be sold first time."]},{"i":"post-stop-sale","l":"[POST] /stop-sale","p":["The /stop-sale service of the Market Route returns data for the Stop Sale transaction according to Transactions. It gets tokenId and a price, returns transaction data by encoding with StopTicketSale method of our Market Contract. It is called to stop sale of a single item."]},{"i":"post-stop-batch-sale","l":"[POST] /stop-batch-sale","p":["The /stop-batch-sale service of the Market Route returns data for the Stop Batch Sale transaction according to Transactions. It gets tokenIds, eventId and a price, returns transaction data by encoding with StopBatchSale method of our Market Contract. It is called to stop sale of all tokenIds under the event with eventId."]},{"i":"post-buy","l":"[POST] /buy","p":["The /buy service of the Market Route returns data for the Buy transaction according to Transactions. It gets tokenIds and a price, returns transaction data by encoding with ticketSale method of our Market Contract. It is called to buy tickets with tokenIds with the corresponding price."]}],[{"i":"ticket-route-ticket","l":"Ticket Route (/ticket)","p":["Ticket Route is implemented to work on tasks that are mainly related to tickets. The Ticker Route does not use any specific modal, therefore, one may have little understanding during the documentation."]},{"i":"get-id","l":"[GET] /:id","p":["The /:id service's aim to get metadata of the ticket with tokenId id. It uses Alchemy's getNftMetadata function to provide requested ticket to the user."]},{"i":"post-mint","l":"[POST] /mint","p":["The /mint service's aim to prepare transaction paramaters for the mint transaction done in frontend. After input validations, it pins image to IPFS. Then, it pins other metadata with ipfs link again to IPFS. Then, with an IPFS link, it prepares the transasction data by calling encodeABI function of our Mint Contract."]},{"i":"post-is-ticket-checked","l":"[POST] /is-ticket-checked","p":["The /is-ticket-checked service's aim to give ticket's controller state to the controller. Firstly, it is an authenticated service. After authentication, it calls NFTItem function of our Market Contract, and looks at used value. If ticket is used, it returns true. Then, it checks if user is really a controller (authenticated one). If yes, it checks if QR code creator is the ticket owner by recovering personel signature from nonce and signature. If yes, it tries to find if the ticket is checked, if yes, it returns true, if no adds to database and returns true."]},{"i":"post-change-ticket-used-state","l":"[POST] /change-ticket-used-state","p":["The /change-ticket-used-state service's aim to change tokens' usage value that is checked by caller and belongs to eventID to true. It returns data of encoded given values as transactionParameters."]}],[{"i":"user-route-user","l":"User Route (/user)","p":["User Route's aim to handle requests that is related to an user's profile provided with corrsponding public address."]},{"i":"get-publicaddress","l":"[GET] /:publicAddress","p":["The /:publicAddress endpoint's aim is to create an user with corresponding public address if user does not exists with that address or return the user if the user exists."]},{"i":"post-update","l":"[POST] /update","p":["The /update service's aim is to update user profile that comes from Authentication Middleware. It updates avatar, name and username of the user in MongoDb."]},{"i":"get-eventspublicaddress","l":"[GET] /events?:publicAddress","p":["The /events?:publicAddress service's aim to get every event that is belonged to publicAddress from MongoDb."]},{"i":"get-ticketspublicaddress","l":"[GET] /tickets?:publicAddress","p":["The /tickets?:publicAddress service's aim to get tickets that is belonged to publicAddress from the chain. It calls ListEventTicketByPublicAddress function of our contract and maps it with our MongoDb Event Modal."]}],[{"i":"utils-route-utils","l":"Utils Route (/utils)","p":["Utils Route's aim to list event with corresponding queries."]},{"i":"get-search-searchtitlepage-pagelimit","l":"[GET] /search?:searchTitle\uD83C\uDD94page:pageLimit","p":["The search endpoint returns pageLimit events that are in the page page with name searchTitle or with id id. It uses Mongodb find function and skips until the page with limit pageLimit."]},{"i":"get-get-events-by-categorycategory","l":"[GET] /get-events-by-category?:category","p":["The /get-events-by-category?:category service's aim to find all events under category category by using MongoDb find function. Returns List of Events."]}],[{"l":"Metamask Provider"},{"i":"why-we-used-such-provider","l":"Why we used such provider?","p":["We wanted to centralize all metamask actions and the loginning to metamask system."]},{"l":"Variables"},{"l":"_uri","p":["It is a string variable which corresponds to chain's uri."]},{"l":"_session","p":["Current active session of Metamask login. default: null."]},{"l":"currentAddress","p":["Connected user's public address, string. default: empty string"]},{"l":"chainId","p":["Constant value equals to 80001 (Mumbai Testnet chain id)"]},{"l":"connector","p":["WalletConnect classed connector with meta variables"]},{"l":"Functions"},{"l":"loginUsingMetamask","p":["If the connector is not connected, it creates new session with .createSession function of connector. Then, chainId, currentAddress and _ session is updated with respect to session's value. Then it notifies all listeners of the provider to update with notifyListeners() function of flutter:provider package."]},{"l":"sign","p":["Used to get sign with respect to nonce. Creates list of strings to give sendCustomRequest function. Firstly, it calls launchUrl with converting session's uri with uri parse, then sends custom request with connector's sendCustomRequest function"]},{"l":"logout","p":["If connector is connected, kills session of connector and erases datas of variables. Then notifies listeners of Metamask Provider"]},{"l":"clear","p":["Clears all variables and notifies listeners."]},{"l":"init","p":["Binds SessionUpdate and Disconnect functions of connector to clear data with clear function."]},{"i":"where-it-is-used","l":"Where it is used?","p":["It is used in wrapper of the app, therefore all the components of the app listens Metamask Provider."]}],[{"l":"User Provider","p":["User Provider is used to login into backend after Metamask Provider done loginWithMetamask. It wraps all the components except Metamask Provider in the wrapper component."]},{"l":"Variables"},{"l":"token","p":["Token is a nullable string which is the JWT token of the user. Empty string if default."]},{"l":"user","p":["User classed object which contains user's data"]},{"l":"Functions"},{"l":"hasToken","p":["Checks if token is defined."]},{"l":"handleLogin","p":["If token is not defined, takes currentAddress from Metamask Provider, gets nonce from the backend, signs the nonce and calls login path of the backend. Gets token from the result and notifies all components under it."]},{"l":"handleUpdate","p":["If metamask provider is changed, gets the current nonce and notifies its listeners."]}],[{"l":"Classes","p":["Every Modal corresponds to a class in the mobile Part. The modals and classes have exactly same attributes. However, to maintain simplicity during the development process, we have implemented toJson and fromJson functions to classes.","toJson and fromJson functions basically takes paramaterized data and converts it to json or takes a json and converts it to parameterized data (Maps).","We use them while we are sending requests or taking request's data."]}],[{"l":"Connection to Backend","p":["Connection to backend is handled with classes we call Services. Every Route of backend has its own Service in the mobile part. The corresponding services basically handles get, put, post requests with function that returns Future values of specific type or a dynamic type.","The services are very estimatable. However, since some constraints, we did not use any form data to handle data from services. Instead, in services we use Map<String, dynamic> (commonly Map<String, String>) to send data with Post requests.","We used the built-in libraries of Flutter to handle JSON data or Requests."]}],[{"l":"Contact Us","p":["We are group of 4 people:","Alper Arı","Sadi Gülbey","Gizem Fıçıcıoğlu","Ahmet Mihça Aydın","You can contact as via our sabanciuniv.edu email addresses:","alperari@sabanciuniv.edu","sadigulbey@sabanciuniv.edu","gizemf@sabanciuniv.edu","ahmetmihca@sabanciuniv.edu","You can contact us for any questions you have or for bug reports."]}]]